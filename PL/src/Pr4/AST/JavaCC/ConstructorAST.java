/* Generated By:JavaCC: Do not edit this line. ConstructorAST.java */
package Pr4.AST.JavaCC;

import Pr4.AST.SemOps;
import Pr4.AST.TinyASint.*;

public class ConstructorAST implements ConstructorASTConstants {
   private SemOps sem = new SemOps();

  final public Prog ProgramaP() throws ParseException {
                      Prog prog;
    prog = Programa();
    jj_consume_token(0);
                                                          {if (true) return prog;}
    throw new Error("Missing return statement in function");
  }

  final public Prog Programa() throws ParseException {
                     Decs decs; Insts insts;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case proc:
    case var:
    case type:
      decs = Declaraciones();
      jj_consume_token(42);
      insts = Instrucciones();
                                                                                  {if (true) return sem.prog_con_decs(decs, insts);}
      break;
    case NumInt:
    case NumReal:
    case not:
    case Null:
    case If:
    case True:
    case While:
    case call:
    case False:
    case New:
    case delete:
    case read:
    case write:
    case nl:
    case Id:
    case cadena:
    case 44:
    case 47:
    case 54:
    case 57:
      insts = Instrucciones();
                                                       {if (true) return sem.prog_sin_decs(insts);}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Decs Declaraciones() throws ParseException {
                         Dec dec; Decs decs;
    dec = Declaracion();
    decs = RD(sem.decs_una(dec));
                                                                               {if (true) return decs;}
    throw new Error("Missing return statement in function");
  }

  final public Decs RD(Decs decsh) throws ParseException {
                         Dec dec; Decs decs;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      dec = Declaracion();
      decs = RD(sem.decs_muchas(decsh, dec));
                                                                 {if (true) return decs;}
      break;
    default:
      jj_la1[1] = jj_gen;
     {if (true) return decsh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Dec Declaracion() throws ParseException {
                      Dec dec;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case var:
      dec = DeclaracionVar();
                            {if (true) return dec;}
      break;
    case type:
      dec = DeclaracionTipo();
                           {if (true) return dec;}
      break;
    case proc:
      dec = DeclaracionProc();
                           {if (true) return dec;}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Dec DeclaracionVar() throws ParseException {
                          Tipo tipo; Token id;
    jj_consume_token(var);
    tipo = Tipo();
    id = jj_consume_token(Id);
                                {if (true) return sem.dec_var(tipo, sem.str(id.image, id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Dec DeclaracionTipo() throws ParseException {
                          Tipo tipo; Token id;
    jj_consume_token(type);
    tipo = Tipo();
    id = jj_consume_token(Id);
                                     {if (true) return sem.dec_tipo(tipo, sem.str(id.image, id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Dec DeclaracionProc() throws ParseException {
                          Token id; ParamsF params; Bloque bloque;
    jj_consume_token(proc);
    id = jj_consume_token(Id);
    params = ParametrosFormales();
    bloque = Bloque();
                                                                     {if (true) return sem.dec_proc(sem.str(id.image, id.beginLine, id.beginColumn), params, bloque);}
    throw new Error("Missing return statement in function");
  }

  final public ParamsF ParametrosFormales() throws ParseException {
                                 ParamsF params;
    jj_consume_token(44);
    params = RPF();
                           {if (true) return params;}
    throw new Error("Missing return statement in function");
  }

  final public ParamsF RPF() throws ParseException {
                   ParamsF params;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case string:
    case record:
    case Int:
    case real:
    case bool:
    case array:
    case pointer:
    case Id:
      params = Parametros();
      jj_consume_token(45);
                                  {if (true) return params;}
      break;
    case 45:
      jj_consume_token(45);
         {if (true) return sem.params_ninguno();}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ParamsF Parametros() throws ParseException {
                         ParamF param; ParamsF params;
    param = Parametro();
    params = RPs(sem.params_uno_f(param));
                                                                {if (true) return params;}
    throw new Error("Missing return statement in function");
  }

  final public ParamsF RPs(ParamsF paramsh) throws ParseException {
                                  ParamF param; ParamsF params;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      param = Parametro();
      params = RPs(sem.params_muchos_f(paramsh, param));
                                                                                {if (true) return params;}
      break;
    default:
      jj_la1[4] = jj_gen;
     {if (true) return paramsh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public ParamF Parametro() throws ParseException {
                       Tipo tipo;
    tipo = Tipo();
                  {if (true) return RP(tipo);}
    throw new Error("Missing return statement in function");
  }

  final public ParamF RP(Tipo tipo) throws ParseException {
                          Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 46:
      jj_consume_token(46);
      id = jj_consume_token(Id);
                  {if (true) return sem.param_f_con_amp(tipo, sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case Id:
      id = jj_consume_token(Id);
             {if (true) return sem.param_f_sin_amp(tipo, sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Bloque Bloque() throws ParseException {
                    Bloque prog;
    jj_consume_token(47);
    prog = ProgramaAux();
    jj_consume_token(48);
                                 {if (true) return prog;}
    throw new Error("Missing return statement in function");
  }

  final public Bloque ProgramaAux() throws ParseException {
                         Prog prog;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NumInt:
    case NumReal:
    case not:
    case Null:
    case proc:
    case If:
    case True:
    case While:
    case call:
    case False:
    case New:
    case delete:
    case read:
    case write:
    case nl:
    case var:
    case type:
    case Id:
    case cadena:
    case 44:
    case 47:
    case 54:
    case 57:
      prog = Programa();
                      {if (true) return sem.bloque_lleno(prog);}
      break;
    default:
      jj_la1[6] = jj_gen;
     {if (true) return sem.bloque_vacio();}
    }
    throw new Error("Missing return statement in function");
  }

  final public Tipo Tipo() throws ParseException {
                Tipo tipo; Token num, id, entero, Real, booleano, str; Campos campos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Id:
      id = jj_consume_token(Id);
              {if (true) return sem.tipo_id(sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case Int:
      jj_consume_token(Int);
           {if (true) return sem.t_int();}
      break;
    case real:
      jj_consume_token(real);
             {if (true) return sem.t_real();}
      break;
    case bool:
      jj_consume_token(bool);
             {if (true) return sem.t_bool();}
      break;
    case string:
      jj_consume_token(string);
               {if (true) return sem.t_cadena();}
      break;
    case array:
      jj_consume_token(array);
      jj_consume_token(49);
      num = jj_consume_token(NumInt);
      jj_consume_token(50);
      jj_consume_token(of);
      tipo = Tipo();
                                                   {if (true) return sem.tipo_array(sem.str(num.image, num.beginLine, num.beginColumn), tipo);}
      break;
    case record:
      jj_consume_token(record);
      jj_consume_token(47);
      campos = Campos();
      jj_consume_token(48);
                                      {if (true) return sem.tipo_registro(campos);}
      break;
    case pointer:
      jj_consume_token(pointer);
      tipo = Tipo();
                           {if (true) return sem.tipo_puntero(tipo);}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Campos Campos() throws ParseException {
                    Campo campo; Campos campos;
    campo = Campo();
    campos = RC(sem.campos_uno(campo));
                                                     {if (true) return campos;}
    throw new Error("Missing return statement in function");
  }

  final public Campos RC(Campos camposh) throws ParseException {
                               Campo campo; Campos campos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      campo = Campo();
      campos = RC(sem.campos_muchos(camposh, campo));
                                                                     {if (true) return campos;}
      break;
    default:
      jj_la1[8] = jj_gen;
     {if (true) return camposh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Campo Campo() throws ParseException {
                   Tipo tipo; Token id;
    tipo = Tipo();
    id = jj_consume_token(Id);
                          {if (true) return sem.campo(tipo, sem.str(id.image, id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Insts Instrucciones() throws ParseException {
                           Inst inst; Insts insts;
    inst = Instruccion();
    insts = RI(sem.insts_una(inst));
                                                       {if (true) return insts;}
    throw new Error("Missing return statement in function");
  }

  final public Insts RI(Insts instsh) throws ParseException {
                            Inst inst; Insts insts;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      inst = Instruccion();
      insts = RI(sem.insts_muchas(instsh, inst));
                                                                      {if (true) return insts;}
      break;
    default:
      jj_la1[9] = jj_gen;
     {if (true) return instsh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Inst Instruccion() throws ParseException {
                       Inst inst; Bloque bloque;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NumInt:
    case NumReal:
    case not:
    case Null:
    case True:
    case False:
    case Id:
    case cadena:
    case 44:
    case 54:
    case 57:
      inst = InstrAsig();
                       {if (true) return inst;}
      break;
    case If:
      inst = InstrIfThen();
                        {if (true) return inst;}
      break;
    case While:
      inst = InstrWhile();
                       {if (true) return inst;}
      break;
    case read:
      inst = InstrLectura();
                         {if (true) return inst;}
      break;
    case write:
      inst = InstrEscritura();
                           {if (true) return inst;}
      break;
    case nl:
      inst = InstrNewLine();
                         {if (true) return inst;}
      break;
    case New:
      inst = InstrReservMem();
                           {if (true) return inst;}
      break;
    case delete:
      inst = InstrLibMem();
                        {if (true) return inst;}
      break;
    case call:
      inst = InstrInvocProc();
                           {if (true) return inst;}
      break;
    case 47:
      bloque = Bloque();
                     {if (true) return sem.inst_comp(bloque);}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Inst InstrAsig() throws ParseException {
                     Exp arg0; Exp arg1;
    arg0 = E0();
    jj_consume_token(51);
    arg1 = E0();
                                  {if (true) return sem.inst_asig(arg0, arg1);}
    throw new Error("Missing return statement in function");
  }

  final public Insts BloqueOpcional() throws ParseException {
                           Insts insts;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NumInt:
    case NumReal:
    case not:
    case Null:
    case If:
    case True:
    case While:
    case call:
    case False:
    case New:
    case delete:
    case read:
    case write:
    case nl:
    case Id:
    case cadena:
    case 44:
    case 47:
    case 54:
    case 57:
      insts = Instrucciones();
                            {if (true) return insts;}
      break;
    default:
      jj_la1[11] = jj_gen;
     {if (true) return sem.insts_ninguna();}
    }
    throw new Error("Missing return statement in function");
  }

  final public Inst InstrIfThen() throws ParseException {
                       Exp exp; Insts insts; Inst inst;
    jj_consume_token(If);
    exp = E0();
    jj_consume_token(then);
    insts = BloqueOpcional();
    inst = RIT(exp, insts);
                                                                       {if (true) return inst;}
    throw new Error("Missing return statement in function");
  }

  final public Inst RIT(Exp exph, Insts insth) throws ParseException {
                                     Insts insts;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Else:
      jj_consume_token(Else);
      insts = BloqueOpcional();
      jj_consume_token(endif);
                                            {if (true) return sem.inst_ifthenelse(exph, insth, insts);}
      break;
    case endif:
      jj_consume_token(endif);
             {if (true) return sem.inst_ifthen(exph, insth);}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Inst InstrWhile() throws ParseException {
                      Exp exp; Insts insts;
    jj_consume_token(While);
    exp = E0();
    jj_consume_token(Do);
    insts = BloqueOpcional();
    jj_consume_token(endwhile);
                                                              {if (true) return sem.inst_while(exp, insts);}
    throw new Error("Missing return statement in function");
  }

  final public Inst InstrLectura() throws ParseException {
                        Exp exp;
    jj_consume_token(read);
    exp = E0();
                      {if (true) return sem.inst_lectura(exp);}
    throw new Error("Missing return statement in function");
  }

  final public Inst InstrEscritura() throws ParseException {
                          Exp exp;
    jj_consume_token(write);
    exp = E0();
                       {if (true) return sem.inst_escritura(exp);}
    throw new Error("Missing return statement in function");
  }

  final public Inst InstrNewLine() throws ParseException {
                        Exp exp;
    jj_consume_token(nl);
           {if (true) return sem.inst_new_line();}
    throw new Error("Missing return statement in function");
  }

  final public Inst InstrReservMem() throws ParseException {
                          Exp exp;
    jj_consume_token(New);
    exp = E0();
                     {if (true) return sem.inst_reserv_mem(exp);}
    throw new Error("Missing return statement in function");
  }

  final public Inst InstrLibMem() throws ParseException {
                       Exp exp;
    jj_consume_token(delete);
    exp = E0();
                        {if (true) return sem.inst_lib_mem(exp);}
    throw new Error("Missing return statement in function");
  }

  final public Inst InstrInvocProc() throws ParseException {
                          Token id; Expresiones exps;
    jj_consume_token(call);
    id = jj_consume_token(Id);
    jj_consume_token(44);
    exps = ListaExpresiones();
    jj_consume_token(45);
                                                     {if (true) return sem.inst_invoc_proc(sem.str(id.image, id.beginLine, id.beginColumn), exps);}
    throw new Error("Missing return statement in function");
  }

  final public Expresiones ListaExpresiones() throws ParseException {
                                   Expresiones exps;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NumInt:
    case NumReal:
    case not:
    case Null:
    case True:
    case False:
    case Id:
    case cadena:
    case 44:
    case 54:
    case 57:
      exps = Expresiones();
                         {if (true) return exps;}
      break;
    default:
      jj_la1[13] = jj_gen;
     {if (true) return sem.exprs_ninguna();}
    }
    throw new Error("Missing return statement in function");
  }

  final public Expresiones Expresiones() throws ParseException {
                              Expresiones exps; Exp exp;
    exp = E0();
    exps = RE(sem.exprs_una(exp));
                                           {if (true) return exps;}
    throw new Error("Missing return statement in function");
  }

  final public Expresiones RE(Expresiones expsh) throws ParseException {
                                       Exp exp; Expresiones exps;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 52:
      jj_consume_token(52);
      exp = E0();
      exps = RE(sem.exprs_muchas(expsh, exp));
                                                         {if (true) return exps;}
      break;
    default:
      jj_la1[14] = jj_gen;
     {if (true) return expsh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E0() throws ParseException {
             Exp arg0, resul;
    arg0 = E1();
    resul = RE0(arg0);
                                {if (true) return resul;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE0(Exp argh) throws ParseException {
                      Exp arg1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 53:
      jj_consume_token(53);
      arg1 = E0();
                    {if (true) return sem.exp("+", argh, arg1);}
      break;
    case 54:
      jj_consume_token(54);
      arg1 = E1();
                   {if (true) return sem.exp("-", argh, arg1);}
      break;
    default:
      jj_la1[15] = jj_gen;
     {if (true) return argh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E1() throws ParseException {
             Exp arg0, resul;
    arg0 = E2();
    resul = RE1(arg0);
                                {if (true) return resul;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE1(Exp exph) throws ParseException {
                      String op; Exp arg1; Exp exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case and:
    case or:
      op = OP1();
      arg1 = E2();
      exp = RE1(sem.exp(op, exph, arg1));
                                                          {if (true) return exp;}
      break;
    default:
      jj_la1[16] = jj_gen;
     {if (true) return exph;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E2() throws ParseException {
             Exp arg0, resul;
    arg0 = E3();
    resul = RE2(arg0);
                                {if (true) return resul;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE2(Exp exph) throws ParseException {
                      String op; Exp arg1; Exp exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
      op = OP2();
      arg1 = E3();
      exp = RE2(sem.exp(op, exph, arg1));
                                                          {if (true) return exp;}
      break;
    default:
      jj_la1[17] = jj_gen;
     {if (true) return exph;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E3() throws ParseException {
             Exp arg0, resul;
    arg0 = E4();
    resul = RE3(arg0);
                                {if (true) return resul;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE3(Exp argh) throws ParseException {
                       String op; Exp arg1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 57:
    case 64:
    case 65:
      op = OP3();
      arg1 = E4();
                         {if (true) return sem.exp(op, argh, arg1);}
      break;
    default:
      jj_la1[18] = jj_gen;
     {if (true) return argh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E4() throws ParseException {
             Exp exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 54:
      jj_consume_token(54);
      exp = E5();
                   {if (true) return sem.exp("-", exp);}
      break;
    case not:
      jj_consume_token(not);
      exp = E4();
                    {if (true) return sem.exp("not", exp);}
      break;
    case NumInt:
    case NumReal:
    case Null:
    case True:
    case False:
    case Id:
    case cadena:
    case 44:
    case 57:
      exp = E5();
              {if (true) return exp;}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E5() throws ParseException {
             Exp arg0, resul;
    arg0 = E6();
    resul = RE5(arg0);
                                {if (true) return resul;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE5(Exp argh) throws ParseException {
                      Exp arg1, resul; Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 49:
      jj_consume_token(49);
      arg1 = E0();
      jj_consume_token(50);
      resul = RE5(sem.exp("[]", argh, arg1));
                                                            {if (true) return resul;}
      break;
    case 55:
      jj_consume_token(55);
      id = jj_consume_token(Id);
      resul = RE5(sem.exp(".", argh, sem.str(id.image, id.beginLine, id.beginColumn)));
                                                                                                {if (true) return resul;}
      break;
    case 56:
      jj_consume_token(56);
      id = jj_consume_token(Id);
      resul = RE5(sem.exp("->", argh, sem.str(id.image, id.beginLine, id.beginColumn)));
                                                                                                  {if (true) return resul;}
      break;
    default:
      jj_la1[20] = jj_gen;
     {if (true) return argh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E6() throws ParseException {
             Exp exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 57:
      jj_consume_token(57);
      exp = E6();
                       {if (true) return sem.exp(exp);}
      break;
    case NumInt:
    case NumReal:
    case Null:
    case True:
    case False:
    case Id:
    case cadena:
    case 44:
      exp = E7();
                  {if (true) return exp;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E7() throws ParseException {
             Exp exp; Token entero, real, verdad, falso, ccadena, id, none;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 44:
      jj_consume_token(44);
      exp = E0();
      jj_consume_token(45);
                           {if (true) return exp;}
      break;
    case NumInt:
      entero = jj_consume_token(NumInt);
                         {if (true) return sem.num_int(sem.str(entero.image, entero.beginLine, entero.beginColumn));}
      break;
    case NumReal:
      real = jj_consume_token(NumReal);
                    {if (true) return sem.num_real(sem.str(real.image, real.beginLine, real.beginColumn));}
      break;
    case True:
      verdad = jj_consume_token(True);
                   {if (true) return sem.verdad();}
      break;
    case False:
      falso = jj_consume_token(False);
                   {if (true) return sem.falso();}
      break;
    case cadena:
      ccadena = jj_consume_token(cadena);
                      {if (true) return sem.cadena(sem.str(ccadena.image, ccadena.beginLine, ccadena.beginColumn));}
      break;
    case Id:
      id = jj_consume_token(Id);
             {if (true) return sem.id(sem.str(id.image, id.beginLine, id.beginColumn));}
      break;
    case Null:
      none = jj_consume_token(Null);
                 {if (true) return sem.none();}
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OP1() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case and:
      jj_consume_token(and);
            {if (true) return "and";}
      break;
    case or:
      jj_consume_token(or);
          {if (true) return "or";}
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OP2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 58:
      jj_consume_token(58);
          {if (true) return "<";}
      break;
    case 59:
      jj_consume_token(59);
         {if (true) return ">";}
      break;
    case 60:
      jj_consume_token(60);
          {if (true) return "<=";}
      break;
    case 61:
      jj_consume_token(61);
          {if (true) return ">=";}
      break;
    case 62:
      jj_consume_token(62);
          {if (true) return "==";}
      break;
    case 63:
      jj_consume_token(63);
          {if (true) return "!=";}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OP3() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 57:
      jj_consume_token(57);
          {if (true) return "*";}
      break;
    case 64:
      jj_consume_token(64);
         {if (true) return "/";}
      break;
    case 65:
      jj_consume_token(65);
         {if (true) return "%";}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public ConstructorASTTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[26];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x2129d090,0x0,0x8000,0x5e002000,0x0,0x0,0x2129d090,0x5e002000,0x0,0x0,0x21295090,0x21295090,0x140000,0x20085090,0x0,0x0,0xc00,0x0,0x0,0x20085090,0x0,0x20084090,0x20084090,0xc00,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x24093fe,0x800,0xc0,0x2101,0x800,0x4100,0x24093fe,0x101,0x800,0x800,0x240933e,0x240933e,0x0,0x2401300,0x100000,0x600000,0x0,0xfc000000,0x2000000,0x2401300,0x1820000,0x2001300,0x1300,0x0,0xfc000000,0x2000000,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x3,};
   }

  public ConstructorAST(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ConstructorASTTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public ConstructorAST(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ConstructorASTTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public ConstructorAST(ConstructorASTTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(ConstructorASTTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[66];
    for (int i = 0; i < 66; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 26; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 66; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
